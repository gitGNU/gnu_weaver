% Permission is granted to copy, distribute and/or modify this
% document under the terms of the GNU Free Documentation License,
% Version 1.3 or any later version published by the Free Software
% Foundation; with no Invariant Sections, no Front-Cover Texts and no
% Back-Cover Texts.  A copy of the license is included in the same
% directory than this file.


\documentclass[11pt,a4paper]{book}
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}


\title{O \textit{Framework} Weaver}
\author{Thiago ``Harry'' Leucz Astrizi}

\begin{document}

\maketitle

\chapter*{Introdução}

No ano de 2009, eu comecei a me interessar mais pelo \textit{hobbie}
de programar jogos em meu computador. Comecei criando algo bem simples
no qual uma joaninha robótica tinha que se desviar de projéteis que
descreviam movimentos parabólicos arremessados por
caranguejos-robôs. Eu usei SDL para fazer o jogo.

Entretanto, fazer aquele projeto não me satisfez. Eu estava
interessado em saber como as coisas realmente funcionavam --- não em
usar uma biblioteca já pronta. O SDL era uma biblioteca
interessante. Mas não tinha muito da minha personalidade nela. Outra
coisa que me incomodava eram as dependências que ela trazia. Isso me
levou a tentar construir a minha própria biblioteca com funções que
permitissem a criação de programas orientados à eventos (como jogos).

A primeira versão da Weaver rodou em meu finado laptop. Ela não rodava
por cima do X, mas por cima do \textit{framebuffer} do
\textit{kernel}. Criar funções para desenhar pontos e linhas foi
trabalhoso. Entretanto, logo percebi que eu estava rumando para um
destino não muito útil. O \textit{framebuffer} era lento demais e
seria frustrante trabalhar somente com uma fração tão pequena do
potencial da minha máquina. Assim, a primeira Weaver foi destruída e
comecei a escrever uma segunda versão que deveria rodar por cima do
servidor X.

A segunda versão da minha biblioteca passou muito tem\-po em
en\-cu\-ba\-ção. Foram muitas semanas de escritas de código, reescritas,
acidentes que me fizeram perder tudo e mais re\-es\-crita. Nunca antes em
um projeto eu fui tão exigente e paguei tão caro por isso. Por duas
vezes, tive que jogar fora milhares de linhas de código por causa do
projeto não estar do jeito que eu desejava. O projeto ainda não estava
com a minha personalidade, o meu jeito. 

Por fim, por volta de junho, uma versão suficientemente estável que me
permitiu criar uma versão de \textit{Pong} ficou pronta. No final de
julho eu já havia criado um clone de \textit{Spacewar!}. E no final de
novembro já havia um clone simplificado de\textit{ Desktop Tower Defense}
usando sprites e animações.

Weaver é uma biblioteca em constante desenvolvimento. Cada vez que eu
inicio um projeto novo com ela, ela fica maior e melhor. Ela se
alimenta de meu trabalho e se desenvolve desta forma. Ao perceber que
uma importante função não está disponível, eu a alimento com mais
linhas de código. 

Ela não é uma biblioteca de criação de jogos como todas as outras. Ela
tem as seguintes características que a tornam especial:

\begin{itemize}
  \item É uma biblioteca estática. Raramente você irá rodar mais de um
    jogo ao mesmo tempo. Logo, bibliotecas compartilhadas não oferecem
    economia de memória como em programas convencionais.
  \item Por causa disso, seus produtos, depois de compilados rodam em
    outras máquinas com o mesmo Sistema Operacional sem a necessidade
    de dependências externas.
  \item É software livre. Você pode alterá-la e modificá-la à vontade.
  \item Tudo o que ela gera também é necessariamente software
    livre. Graças ao fato dela ser GPL e ser inserida estaticamente no
    código dos jogos.
  \item Ela é (ou tenta ser) muito bem-documentada. Desta forma,
    aprender a usá-la torna-se fácil e você ainda aprenderá como ela é
    feita caso queira alterá-la.
  \item Além de ser uma biblioteca, ela também é um programa e um
    arcabouço (\textit{framework}). Basta digitar \textbf{weaver
      meujogo}, que um diretório chamado ``meujogo'' será criado com
    um código mínimo nes\-ces\-sá\-rio para criar um jogo.
  \item Ela é exclusiva para sistemas GNU/Linux.
  \item Possui vários recursos que agilizam a criação de novos
    projetos e a criação de extensões em projetos já existentes. Tudo
    isso na lingüagem C.
\end{itemize}

Nos próximos capítulos deste documento, você encontrará um guia
completo de como instalar e usar a Weaver. No apêndice existe também
um guia de referência para todas as funções presentes na API
Weaver. Divirta-se!

\chapter{Instalando Weaver em seu Computador}

Weaver foi projetada para funcionar em sistemas GNU/Linux. Se você não
utiliza este sistema, talvez você até consiga instalar o programa, mas
pode ser um tanto difícil. Você terá que tentar por sua própria conta
e risco. Se você usa GNU/Linux, então o processo será bastante simples.

A primeira coisa que você deve obter é um arquivo compactado
(possivelmente em tar.gz ou tar.bz2) com o código-fonte da Weaver. Se
você está lendo isso, possivelmente você já obteve o
código-fonte. Caso contrário, tente procurar utilizando algum
mecanismo de busca na Internet.

Descompacte o arquivo, vá para dentro do diretório obtido e use o
comando:

\begin{verbatim}
make install
\end{verbatim}

Caso algum problema apareça nesta parte, provavelmente estão faltando
algumas dependências. Provavelmente os arquivos de desenvolvimento
para Xlib, Vorbis ou ALSA. Instale os pacotes que estiverem faltando
antes de continuar.

Feito isso, o \textit{framework} será instalado na sua máquina. O
script Weaver será colocado por padrão em /usr/bin. O código da API e
todos os arquivos necessários para gerar projetos iniciais serão
colocados em /usr/share/weaver.

Vamos testar e ver se tudo está funcionando? Basta digitar no
terminal:

\begin{verbatim}
weaver dummy
\end{verbatim}

Depois deste comando, será criado um novo diretório chamado ``dummy''
que contém um código mínimo necessário para se criar um projeto
Weaver. Entre neste diretório e use o comando:

\begin{verbatim}
make
\end{verbatim}

O projeto será compilado. Se você executá-lo, encontrará um jogo vazio
que será encerrado assim que qualquer tecla de seu teclado for
pressionada. Se você conferir o código deste projeto no arquivo
``src/game.c'', encontrará um código como este:

\begin{verbatim}
#include "weaver/weaver.h"
#include "game.h"
\end{verbatim}

Isso chama os cabeçalhos necessários para o seu
jogo. O ``weaver/weaver.h'' é o mais importante. Ele declara todas as
funções presentes na API Weaver. O ``game.h'' está vazio por enqüanto.  

\begin{verbatim}
int main(int argc, char **argv){
  awake_the_weaver(); // Initializing Weaver API
\end{verbatim}

Esta é a função principal e abaixo dela, uma função que inicializa a
API Weaver. Todos os projetos feitos usando o \textit{framework}
Weaver devem começar com ela.

\begin{verbatim}
  // Main loop
  for(;;){
    get_input();
    if(keyboard[ANY]){
      break;
    }

    weaver_rest(10000000);
  }
\end{verbatim}

Este é o loop principal. Um loop infinito dentro do qual o seu jogo
irá rodar. No começo de cada iteração do loop, deve-se verificar se o
usuário pressionou alguma tecla, mecheu o mouse, clicou em algo,
etc. Isso é feito com a função ``get\_input()''.

Em seguida, devemos reagir de acordo caso o usuário tenha apertado
alguma tecla relevante. Neste caso, verificamos se qualquer (ANY)
tecla foi pressionada e saímos do loop principal se isso aconteceu.

Caso contrário, continuamos dentro do loop. Invocamos a função
``wea\-ver\_rest()'' que faz duas coisas: primeiro, ela fica sem fazer
nada pelo número de nanossegundos passado como argumento. Neste caso,
10000000 de nanos\-segundos é equivalente a 0,1 segundos. Isso faz com
que o jogo não gaste processamento desnecessariamente por causa do seu
loop infinito. Neste tempo, o seu computador tem um tempo livre para
cuidar de outros processos que podem estar sendo executados.

Outra coisa que esta função faz é calcular a quantos frames por
segundo o seu jogo está rodando. Ele armazena o resultado na variável
global ``fps''. Neste caso, o valor deve ser de 99 frames por segundo,
já que o jogo está vazio e nada está sendo feito.

\begin{verbatim}
  may_the_weaver_sleep();
  return 0;
}
\end{verbatim}

Finalmente, este é o fim do código do programa. Ele encerra a API
Weaver e encerra o programa retornando o código 0 (de sucesso) para o
seu Sistema Operacional.

\chapter{Fazendo uma Bolinha Quicar na Tela}

Vamos então começar a programar. Comecemos com o equivalente ao
``Hello World'' do mundo dos jogos. Vamos fazer uma bolinha ficar
quicando pela sua tela. Ela ficará se locomovendo infinitamente até
você encerrar o programa pressionando ESC.

Primeiro, comece um projeto digitando:

\begin{verbatim}
weaver ball
\end{verbatim}

Abra o arquivo ball/src/game.c e adicione o cabeçalho:

\begin{verbatim}
#define RADIUS 30
\end{verbatim}

Este é o raio da bolinha que ficará se movendo pela tela. No exemplo,
estamos deixando ele com 30 pixels. Você pode deixá-la maior ou menor
se preferir.

Para este ``jogo'', vamos precisar armazenar as coordenadas do centro
da bolinha, bem como o quanto ela irá se deslocar horizontal e
verticalmente a cada \textit{frame}. Para isso, comece declarando no
começo da função principal as variáveis necessárias:

\begin{verbatim}
int ball_x, ball_y, dx, dy;
\end{verbatim}

Depois da função ``awake\_the\_weaver()'', nós já teremos obtido
algumas informações que nos serão úteis. Como por exemplo, o tamanho
da nossa tela. Só então poderemos inicializar os valores que
declaramos:

\begin{verbatim}
ball_x = window_width / 2;
ball_y = window_height / 2;
dx = dy = 2;
\end{verbatim}

Isso fará com que a nossa bolinha comece no centro da tela e se
desloque a cada \textit{frame} 2 pixels horizontalmente e 2 pixels
verticalmente. As variáveis ``window\_width'' e ``window\_height'' são
globais e são inicializadas pelo \\``awake\_the\_weaver()''.

Agora, dentro do \textit{loop} principal, depois do código que lida
com o encerramento do programa caso o usuário pressione alguma tecla,
adicione uma função para apagar a bolinha da tela pintando ela de
preto:

\begin{verbatim}
draw_circle(circle_x, circle_y, RADIUS, BLACK);
\end{verbatim}

Em seguida, coloque o código que controla o deslocamento da bolinha:

\begin{verbatim}
ball_x += dx;
ball_y += dy;
\end{verbatim}

Agora vamos colocar código que controla o que acontece quando a
bolinha atinge os limites da tela:

\begin{verbatim}
if(ball_y < RADIUS || ball_y > window_height - RADIUS)
   dy *= -1;
if(ball_x < RADIUS || ball_x > window_width - RADIUS)
   dx *= -1;
\end{verbatim}

E finalmente, depois de apagarmos a bolinha e mudarmos sua posição, é
hora de desenhar ela de novo:

\begin{verbatim}
draw_circle(circle_x, circle_y, RADIUS, RED);
\end{verbatim}

As macros BLACK e RED vistas acima são definidas pela API Weaver. Além
delas, existem muitas outras (GREEN, YELLOW, ORANGE, PINK, CYAN,
...). Para ver uma lista, basta ver o arquivo src/weaver/display.h.

Bem, o seu jogo está pronto. Basta agora compilá-lo com um
\texttt{make} e executar o programa \texttt{ball} gerado. Você também
pode instalá-lo com um \texttt{make install} se quiser. 

Como pode ver, fazer um programa com uma bolinha se deslocando é muito
fácil com a Weaver. Foram só 12 linhas de código. Para uma versão mais
elaborada que tenha som e uma bolinha com textura, consulte o
diretório \texttt{examples} que vem junto com o código-fonte da
Weaver.

\end{document}
